# Http 缓存，浏览器缓存

缓存是一个很“大”的概念，尤其是 WEB 缓存，可以被分为很多种，比如：
- 数据库缓存
- (代理)服务器缓存
- CDN 缓存
- 浏览器缓存

本文讲的 HTTP 缓存也就是浏览器缓存

HTTP 缓存官方概念

> HTTP 缓存（或浏览器缓存）是用于临时存储（缓存）Web 文档（如 HTML 页面或图像）,以减少服务延迟的一种技术。HTTP 缓存系统会保存下通过这套系统下的文档的副本；如果满足条件，则可以缓存满足后续需求。HTTP 缓存系统可以指设备，也可以指计算机程序。

《HTTP 权威指南》，是这样介绍缓存的：
> 在前端开发中，性能一直都是被大家重视的一点，然而判断一个网站的性能最直观就是判断网页的打开速度。其中提升网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

缓存在网站开发中，给我们带来了下面的一些好处：
- 使得网页加载和呈现速度更快
- 减少了不必要的数据传输，从而节省了网络流量和带宽
- 在上一步的基础上,服务器的负担因而减少

浏览器缓存的分类有多种，按照缓存位置分类有：
- memory cache
- disk cache
- Service Worker 等
浏览器的资源缓存分为 from disk cache 和 from memory cache 两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘保留一份副本。当刷新页面，如果缓存没有过期，会直接从内存中拉取资源。当用户关闭页面后，当前页面在内存中缓存的资源会被清空。再一次缓存页面时，如果缓存没有过期。将会从本地磁盘获取资源。

from disk cache 和 from memory cache 的区别是：
当在 chrome 访问 url 时，页面上的 HTML 或者是其他资产（图片） 将会本地存储在内存和磁盘中。chrome 将会优先使用内存缓存，因为内存缓存快得多。但为了避免浏览器退出或者是崩溃，也会将资源存储在磁盘缓存中。因为磁盘缓存是持久的。

按照缓存的失效策略，有：
- 强缓存
- 协商缓存

![缓存策略](./assets/http-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5.png "缓存策略")

**强缓存**

强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。
那么这个过程中就会涉及到有效时间的判断。HTTP1.0 和 HTTP1.1 在有效时间的判断上会有些不同。

HTTP1.0 有效时间的判断
HTTP1.0 版本规定 response header 字段 Expires，它对应一个未来的时间戳。客户端在第一次请求之后，服务端下发 Expires 响应头字段，当客户端再次请求资源时。会先对比当前时间和 Expires 中的响应时间。如果当前时间早于 Expires 时间，那么会直接使用缓存数据，反之会重新发送请求，更新数据。响应数据格式如下：

```javascript
Expires:Tue, 13 May 2020 09:33:34 GMT
```
Expires 为负数的情况下等同于 no-cache, 正数或零同 max-age 的表意是相同。

但是使用 Expires 响应头存在一些小的瑕疵，比如：
1. 客户端和服务端的时间不一致
2. 格式较为复杂，多个空格就会导致设置失败

HTTP1.1 有效时间判断
HTTP1.1 服务端使用 Cache-control 这个 response header，它具备多个不同的值：
- private: 私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存
- public: 共有缓存，可被代理服务器缓存，比如: CDN ,允许多用户间共享
- max-age: 单位是秒，表示缓存的内容在该值后过期
- no-cache: 需要使用协商缓存，这个字段并不表示不需要使用缓存，无论本地副本是否过期，都需要到服务器进行副文本有效校验
- no-store: 所有内容都不会缓存
- must-revalidate: 告诉浏览器，缓存服务器，本地副本过期前可以使用本地副本，但是过期后必须去服务器进行有效性校验

```javascript
cache-control: private, max-age=0, must-revalidate
```
上述语句表示：该资源只能被浏览器缓存，不能被代理服务器缓存，资源立马过期，浏览器需要验证资源是否过期，可能会使用协商缓存进行判断。
HTTP 规定，如果 cache-control 中的 max-age 的优先级高于 expires
![cache-control总结](./assets/http-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5.png "cache-control总结")

**协商缓存**
强缓存的本质是浏览器判断缓存资源是否超过某个时间或者是某个时间段，由于服务器的时间和本地浏览器的时间不一致，很可能会造成判断失误，资源没有及时更新。从优化的角度来说，我们真正关心的是服务的文件是否进行了变化，所以我们需要用到协商缓存。

协商缓存过程： 在浏览器端，当某个资源没有命中强缓存时，浏览器就会发送一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回 304

服务端掌握着最新的资源，根据 HTTP 协议，服务端会根据 【last-modified, if-last-modified-since】 和 【etag,if-none-match】这两对 header 做对比。

我们先来看看【last-modified、last-modified-since】这对 header 主导的协商缓存过程：
- 浏览器第一次请求资源时，服务端在返回资源的响应头加入 last-modified 字段，这个字段表示这个资源在服务端最近的修改时间。
- 浏览器收到响应，并记录 last-modified 时间为 T
- 浏览器再次向服务端请求资源时，请求头加上 if-modified-since 的 header, 这个 if-modified-since 的值正是上一次请求该资源时，后端返回的 last-modified 响应头 T
- 服务端再次收到请求，根据请求头 if-modified-since 的值 T ，判断相关资源在 时间 T 内是否发生了变化，如果没有发生变化，就返回 304，且不返回资源内容。浏览器从缓存中获取。如果发生变化，就返回最新的资源，且更新 last-modifiedd 的值。

这种时间的判断方式和 HTTP1.0 的 expires 的问题相似，如果客户端的时间不准确，就会导致判断不正确。所以就有了 【Etag、和 if-none-match】这一对 header 来进行协商缓存
- 浏览器第一次请求资源时，服务端在返回资源的响应头上加上 Etag 字段，Etag 是文件对应的 hash 值，不同文件对应的是不同的 hash 值.
- 浏览器收到响应并记录这个 Etag 为 E
- 浏览器再次向服务器请求这个资源时，会在请求头上加上 if-none-match ，值为 E
- 服务端再次收到请求时，会根据资源生成一个新的 Etag，并和请求头中的 if-none-match 做对比。如果两个值相同就返回 304, 不同就正常返回资源内容，并更新 Etag
Etag 的生成策略并没有什么强制说明，取决于平台自主实现方式。Etag 的优先级高于 last-modified，不同服务器产生的 Etag 可能是不相同的，所以对于服务集群处理请求的网站来说，Etag 的匹配率反而会降低，会有更大的开销。
在实际应用中，我们可能会将强缓存和协商缓存结合使用，所以他们的优先级顺序是： cache-control、expires、etag、last-modified
